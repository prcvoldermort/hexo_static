{"meta":{"title":"果果家","subtitle":"记录中","description":null,"author":"Zhang Yuan","url":"http://blog.guoguojia.net"},"pages":[{"title":"tags","date":"2019-01-01T10:09:29.000Z","updated":"2019-01-01T10:10:25.483Z","comments":false,"path":"tags/index.html","permalink":"http://blog.guoguojia.net/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-01T10:10:35.000Z","updated":"2019-01-01T10:11:08.391Z","comments":false,"path":"categories/index.html","permalink":"http://blog.guoguojia.net/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Javascript中的异步操作一--回调","slug":"Javascript中的异步操作一-回调函数","date":"2019-01-08T04:20:40.000Z","updated":"2019-01-08T04:20:40.864Z","comments":true,"path":"2019/01/08/Javascript中的异步操作一-回调函数/","link":"","permalink":"http://blog.guoguojia.net/2019/01/08/Javascript中的异步操作一-回调函数/","excerpt":"","text":"本文翻译自(https://javascript.info/callbacks)[https://javascript.info/callbacks] 回调JavaScript中有许多操作都是异步的，例如下面的loadScript(src): 12345function loadScript(src) &#123; let script = document.createElement('script'); script.src = src; document.head.append(script);&#125; 这个函数是用来加载新的脚本的，运行时把&lt;script src=&quot;…&quot;&gt;添加到文档流中，当浏览器解析到这个地方时执行。可以这样使用：12// 加载并执行脚本loadScript('/my/script.js'); 这个方法被称为异步函数，因为这个加载脚本的操作不是立刻完成，而是稍后完成的。 这个方法首先初始化脚本，然后执行代码。在脚本加载的过程中，这个方法下的代码有可能已经执行完毕，如果这个过程非常耗时，那其余的代码也有可能同时执行。 123loadScript('/my/script.js');// loadScript方法下面的代码不会等待其执行完毕才开始执行// ... 假设我们想调用通过loadScript方法加载到的代码中的newFunction方法，你会发现下面的代码不会执行： 123loadScript('/my/script.js'); // 脚本中有\"function newFunction() &#123;…&#125;\"newFunction(); // 没有这个方法！！！ 浏览器可能来不及加载完整的脚本，因此立即调用newFunction方法会失败，在当前的情况下，loadScript方法不能追踪代码加载的完成与否，脚本加载并最终执行，这就是这段代码做的事情，但是我们需要知道具体什么时间加载，什么时候开始执行才能正确使用脚本中的新方法和变量。 我们来为loadScipt方法加上第二个参数callback，来作为脚本加载完后执行的回调。 12345678function loadScript(src, callback) &#123; let script = document.createElement('script'); script.src = src; script.onload = () =&gt; callback(script); document.head.append(script);&#125; 现在可以将脚本中定义的方法写在回调中来调用它： 12345loadScript('/my/script.js', function() &#123; // the callback runs after the script is loaded newFunction(); // 现在可以执行了 ...&#125;); 这就对了，第二个参数是脚本加载完成后执行的函数(通常是匿名函数). 以下是一个现实中的可执行的示例: 1234567891011function loadScript(src, callback) &#123; let script = document.createElement('script'); script.src = src; script.onload = () =&gt; callback(script); document.head.append(script);&#125;loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script =&gt; &#123; alert(`Cool, the $&#123;script.src&#125; is loaded`); alert( _ ); // function declared in the loaded script&#125;); 这就是所谓的”基于回调的”异步编程方式，一个异步执行的方法应该包括一个回调方法供其执行完毕后调用。 这里是以loadScript为例来说明的，是一种通行的做法。 回调中的回调那么如何顺序加载两段脚本呢？ 自然而然会想到把第二段loadScript脚本放在第一段loadScript脚本的回调中: 123456789loadScript('/my/script.js', function(script) &#123; alert(`Cool, the $&#123;script.src&#125; is loaded, let's load one more`); loadScript('/my/script2.js', function(script) &#123; alert(`Cool, the second script is loaded`); &#125;);&#125;); 当外层的loadScript加载完毕后，再加载里面的回调。 那如果再加更多层的脚本呢？ 1234567891011loadScript('/my/script.js', function(script) &#123; loadScript('/my/script2.js', function(script) &#123; loadScript('/my/script3.js', function(script) &#123; // ...continue after all scripts are loaded &#125;); &#125;)&#125;); 每一个新的方法都嵌套在一个回调中，这样多几层还行，再多层就不好使了，随后我们会看到其他的变通方法。 错误处理在上面的例子中我们没有考虑错误的情况。假如脚本加载失败呢，我们的代码理应对错误做出反应。 这是可以追踪加载错误的loadScript改进版本代码： 123456789function loadScript(src, callback) &#123; let script = document.createElement('script'); script.src = src; script.onload = () =&gt; callback(null, script); script.onerror = () =&gt; callback(new Error(`Script load error for $&#123;src&#125;`)); document.head.append(script);&#125; 对于成功的加载调用callback(null, script), 对于失败的加载调用callback(error). 使用方法： 1234567loadScript(&apos;/my/script.js&apos;, function(error, script) &#123; if (error) &#123; // 处理错误 &#125; else &#123; // 脚本成功加载 &#125;&#125;); 以上的用法非常常见，称作”错误优先回调”. 约定如下： 回调的第一个参数保留用作错误处理，当错误发生时，调用callback(err) 第二个及后面的参数供成功的情况下使用，然后调用callback(null, result1, result2…) 这样callback方法就可以同时用来报错和返回结果了。 嵌套的噩梦第一眼看上去，这种异步编程模式切实可行，对于一到两层的嵌套看上去不错，但是对于更多层的嵌套就不是这么回事了： 1234567891011121314151617181920212223loadScript('1.js', function(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ... loadScript('2.js', function(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ... loadScript('3.js', function(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ...在所有脚本都加载好后执行 (*) &#125; &#125;); &#125; &#125;) &#125;&#125;); 上面的代码中： 加载1.js，如果没有报错，然后 加载2.js, 如果没有报错，然后 加载3.js，如果没有报错，然后继续执行 当嵌套更多的层级时，代码就会越来越难以维护，特别是...处换成包含各种循环、条件判断的真实的代码。 这就被称作回调地狱或嵌套的噩梦。 这种代码不是非常好，可以尝试把每一步写成单独的方法来缓解这个问题，像这样： 123456789101112131415161718192021222324252627loadScript('1.js', step1);function step1(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ... loadScript('2.js', step2); &#125;&#125;function step2(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ... loadScript('3.js', step3); &#125;&#125;function step3(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ...continue after all scripts are loaded (*) &#125;&#125;; 这段代码把代码的嵌套写成了单独的方法，做的事情还是一样的。 这种方法起作用，但代码看起来像是一段撕碎的电子表格，需要眼球跳来跳去，很难阅读。这很不方便，特别是读者不熟悉代码的情况下都不知道眼球应该放哪里。 还有一个问题是命名为step*的方法是用来避免嵌套噩梦的，都只能用一次，没有人会在方法链外再次使用，因此可能会造成命名空间的混杂。 我们需要更好的方法来处理这个问题。 幸运的是，的确有办法可以避免这样的噩梦，那就是下一章介绍的promises（保证）。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://blog.guoguojia.net/tags/Javascript/"},{"name":"语法","slug":"语法","permalink":"http://blog.guoguojia.net/tags/语法/"},{"name":"异步操作","slug":"异步操作","permalink":"http://blog.guoguojia.net/tags/异步操作/"}]},{"title":"Laravel最佳实践","slug":"laravel-best-practices","date":"2019-01-03T03:42:41.000Z","updated":"2019-01-03T07:03:48.270Z","comments":true,"path":"2019/01/03/laravel-best-practices/","link":"","permalink":"http://blog.guoguojia.net/2019/01/03/laravel-best-practices/","excerpt":"","text":"翻译自：https://github.com/alexeymezenin/laravel-best-practices contents单一责任原则胖模型，瘦控制器校验业务逻辑应该写在服务类中不要重复自己的代码(DRY)尽量使用Eloquent与collections做数据库查询批量赋值不要在Blade模板中做查询，使用实时加载(N+1问题)给代码添加注释，尽量使用描述性的方法和变量名来取代代码注释Blade模板中不要加JS和CSS，不要在PHP类中加HTML使用配置、语言文件和定义常量来取代代码中的文字使用被社区广为接受的标准Laravel工具遵循Laravel命名规范在可能的地方使用更短可读性更强的句法用控制反转容器或门面来取代new一个新的对象不要直接从.env文件中读取数据以标准格式存储数据，使用存取器和变异器来修改日期格式其他好的实践 single-responsibility-principle单一责任原则一个类，一个方法应该只做一件事情 不好的做法： 12345678public function getFullNameAttribute()&#123; if (auth()-&gt;user() &amp;&amp; auth()-&gt;user()-&gt;hasRole('client') &amp;&amp; auth()-&gt;user()-&gt;isVerified()) &#123; return 'Mr. ' . $this-&gt;first_name . ' ' . $this-&gt;middle_name . ' ' . $this-&gt;last_name; &#125; else &#123; return $this-&gt;first_name[0] . '. ' . $this-&gt;last_name; &#125;&#125; 好的做法： 12345678910111213141516171819public function getFullNameAttribute()&#123; return $this-&gt;isVerifiedClient() ? $this-&gt;getFullNameLong() : $this-&gt;getFullNameShort();&#125;public function isVerifiedClient()&#123; return auth()-&gt;user() &amp;&amp; auth()-&gt;user()-&gt;hasRole('client') &amp;&amp; auth()-&gt;user()-&gt;isVerified();&#125;public function getFullNameLong()&#123; return 'Mr. ' . $this-&gt;first_name . ' ' . $this-&gt;middle_name . ' ' . $this-&gt;last_name;&#125;public function getFullNameShort()&#123; return $this-&gt;first_name[0] . '. ' . $this-&gt;last_name;&#125; 🔝 回到顶部 fat-models-skinny-controllers胖模型，瘦控制器不要使用查询构造器或SQL语句来查询数据库，把所有有关数据库操作的代码写在Eloquent模型或Repository类中 不好的做法： 12345678910public function index()&#123; $clients = Client::verified() -&gt;with(['orders' =&gt; function ($q) &#123; $q-&gt;where('created_at', '&gt;', Carbon::today()-&gt;subWeek()); &#125;]) -&gt;get(); return view('index', ['clients' =&gt; $clients]);&#125; 好的做法： 12345678910111213141516public function index()&#123; return view('index', ['clients' =&gt; $this-&gt;client-&gt;getWithNewOrders()]);&#125;class Client extends Model&#123; public function getWithNewOrders() &#123; return $this-&gt;verified() -&gt;with(['orders' =&gt; function ($q) &#123; $q-&gt;where('created_at', '&gt;', Carbon::today()-&gt;subWeek()); &#125;]) -&gt;get(); &#125;&#125; 🔝 回到顶部 validation校验把表单校验逻辑从控制器挪到请求类中 不好的做法 12345678910public function store(Request $request)&#123; $request-&gt;validate([ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', 'publish_at' =&gt; 'nullable|date', ]); ....&#125; 好的做法： 12345678910111213141516public function store(PostRequest $request)&#123; ....&#125;class PostRequest extends Request&#123; public function rules() &#123; return [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', 'publish_at' =&gt; 'nullable|date', ]; &#125;&#125; 🔝 回到顶部 business-logic-should-be-in-service-class业务逻辑应该写在服务类中一个控制器必须只做一件事情，因此把业务逻辑从控制器挪到服务类中 不好的做法： 12345678public function store(Request $request)&#123; if ($request-&gt;hasFile('image')) &#123; $request-&gt;file('image')-&gt;move(public_path('images') . 'temp'); &#125; ....&#125; 好的做法： 12345678910111213141516public function store(Request $request)&#123; $this-&gt;articleService-&gt;handleUploadedImage($request-&gt;file('image')); ....&#125;class ArticleService&#123; public function handleUploadedImage($image) &#123; if (!is_null($image)) &#123; $image-&gt;move(public_path('images') . 'temp'); &#125; &#125;&#125; 🔝 回到顶部 dont-repeat-yourself-dry不要重复自己的代码(DRY)尽可能的复用代码，包括blade模板中的代码和使用Eloquent scope 不好的做法： 1234567891011public function getActive()&#123; return $this-&gt;where('verified', 1)-&gt;whereNotNull('deleted_at')-&gt;get();&#125;public function getArticles()&#123; return $this-&gt;whereHas('user', function ($q) &#123; $q-&gt;where('verified', 1)-&gt;whereNotNull('deleted_at'); &#125;)-&gt;get();&#125; 好的做法： 12345678910111213141516public function scopeActive($q)&#123; return $q-&gt;where('verified', 1)-&gt;whereNotNull('deleted_at');&#125;public function getActive()&#123; return $this-&gt;active()-&gt;get();&#125;public function getArticles()&#123; return $this-&gt;whereHas('user', function ($q) &#123; $q-&gt;active(); &#125;)-&gt;get();&#125; 🔝 回到顶部 Prefer to use Eloquent over using Query Builder and raw SQL queries. Prefer collections over arrays尽量使用Eloquent与collections做数据库查询Eloquent让你可以写出可读性强、可维护性强的代码，它还支持软删除、事件操作等等优势 不好的做法： 123456789101112SELECT *FROM `articles`WHERE EXISTS (SELECT * FROM `users` WHERE `articles`.`user_id` = `users`.`id` AND EXISTS (SELECT * FROM `profiles` WHERE `profiles`.`user_id` = `users`.`id`) AND `users`.`deleted_at` IS NULL)AND `verified` = '1'AND `active` = '1'ORDER BY `created_at` DESC 好的做法： 1Article::has('user.profile')-&gt;verified()-&gt;latest()-&gt;get(); 🔝 回到顶部 Mass assignment批量赋值不好的做法： 1234567$article = new Article;$article-&gt;title = $request-&gt;title;$article-&gt;content = $request-&gt;content;$article-&gt;verified = $request-&gt;verified;// Add category to article$article-&gt;category_id = $category-&gt;id;$article-&gt;save(); 好的做法： 1$category-&gt;article()-&gt;create($request-&gt;all()); 🔝 回到顶部 Do not execute queries in Blade templates and use eager loading (N + 1 problem)不要在Blade模板中做查询，使用实时加载(N+1问题)不好的做法（对于100个用户，做了101次查询）： 123@foreach (User::all() as $user) &#123;&#123; $user-&gt;profile-&gt;name &#125;&#125;@endforeach 好的做法（对于100个用户，只做了两次查询）： 1234567$users = User::with('profile')-&gt;get();...@foreach ($users as $user) &#123;&#123; $user-&gt;profile-&gt;name &#125;&#125;@endforeach 🔝 回到顶部 Comment your code, but prefer descriptive method and variable names over comments给代码添加注释，尽量使用描述性的方法和变量名来取代代码注释不好的做法： 1if (count((array) $builder-&gt;getQuery()-&gt;joins) &gt; 0) 好一些的做法： 12// Determine if there are any joins.if (count((array) $builder-&gt;getQuery()-&gt;joins) &gt; 0) 很好的做法： 1if ($this-&gt;hasJoins()) 🔝 回到顶部 Do not put JS and CSS in Blade templates and do not put any HTML in PHP classesBlade模板中不要加JS和CSS，不要在PHP类中加HTML不好的做法： 1let article = `&#123;&#123; json_encode($article) &#125;&#125;`; 好一些的做法： 12345&lt;input id=\"article\" type=\"hidden\" value=\"@json($article)\"&gt;Or&lt;button class=\"js-fav-article\" data-article=\"@json($article)\"&gt;&#123;&#123; $article-&gt;name &#125;&#125;&lt;button&gt; 在Javascript文件中： 1let article = $('#article').val(); 最好用专门的代码在PHP端包装数据，在JS端解析数据 🔝 回到顶部 Use config and language files, constants instead of text in the code使用配置、语言文件和定义常量来取代代码中的文字不好的做法： 123456public function isNormal()&#123; return $article-&gt;type === 'normal';&#125;return back()-&gt;with('message', 'Your article has been added!'); 好的做法： 123456public function isNormal()&#123; return $article-&gt;type === Article::TYPE_NORMAL;&#125;return back()-&gt;with('message', __('app.article_added')); 🔝 回到顶部 Use standard Laravel tools accepted by community使用被社区广为接受的标准Laravel工具不要任意使用第三方的包和工具，要选用被社区广为接受的标准Laravel工具，不要坑你的客户 任务 标准工具 第三方工具 Authorization Policies Entrust, Sentinel and other packages Compiling assets Laravel Mix Grunt, Gulp, 3rd party packages Development Environment Homestead Docker Deployment Laravel Forge Deployer and other solutions Unit testing PHPUnit, Mockery Phpspec Browser testing Laravel Dusk Codeception DB Eloquent SQL, Doctrine Templates Blade Twig Working with data Laravel collections Arrays Form validation Request classes 3rd party packages, validation in controller Authentication Built-in 3rd party packages, your own solution API authentication Laravel Passport 3rd party JWT and OAuth packages Creating API Built-in Dingo API and similar packages Working with DB structure Migrations Working with DB structure directly Localization Built-in 3rd party packages Realtime user interfaces Laravel Echo, Pusher 3rd party packages and working with WebSockets directly Generating testing data Seeder classes, Model Factories, Faker Creating testing data manually Task scheduling Laravel Task Scheduler Scripts and 3rd party packages DB MySQL, PostgreSQL, SQLite, SQL Server MongoDB 🔝 回到顶部 Follow Laravel naming conventions遵循Laravel命名规范遵循PSR规范 PSR标准 同时遵循Laravel社区接受的命名传统 称呼什么 怎么样的 好的 不好的 Controller singular ArticleController ArticlesController Route plural articles/1 article/1 Named route snake_case with dot notation users.show_active users.show-active, show-active-users Model singular User Users hasOne or belongsTo relationship singular articleComment articleComments, article_comment All other relationships plural articleComments articleComment, article_comments Table plural article_comments article_comment, articleComments Pivot table singular model names in alphabetical order article_user user_article, articles_users Table column snake_case without model name meta_title MetaTitle; article_meta_title Model property snake_case $model-&gt;created_at $model-&gt;createdAt Foreign key singular model name with _id suffix article_id ArticleId, id_article, articles_id Primary key - id custom_id Migration - 2017_01_01_000000_create_articles_table 2017_01_01_000000_articles Method camelCase getAll get_all Method in resource controller table store saveArticle Method in test class camelCase testGuestCannotSeeArticle test_guest_cannot_see_article Variable camelCase $articlesWithAuthor $articles_with_author Collection descriptive, plural $activeUsers = User::active()-&gt;get() $active, $data Object descriptive, singular $activeUser = User::active()-&gt;first() $users, $obj Config and language files index snake_case articles_enabled ArticlesEnabled; articles-enabled View snake_case show_filtered.blade.php showFiltered.blade.php, show-filtered.blade.php Config snake_case google_calendar.php googleCalendar.php, google-calendar.php Contract (interface) adjective or noun Authenticatable AuthenticationInterface, IAuthentication Trait adjective Notifiable NotificationTrait 🔝 回到顶部 Use shorter and more readable syntax where possible在可能的地方使用更短可读性更强的句法不好的做法： 12$request-&gt;session()-&gt;get('cart');$request-&gt;input('name'); 好的做法： 12session('cart');$request-&gt;name; 更多的例子： 一般的句法 短小精悍的句法 Session::get(&#39;cart&#39;) session(&#39;cart&#39;) $request-&gt;session()-&gt;get(&#39;cart&#39;) session(&#39;cart&#39;) Session::put(&#39;cart&#39;, $data) session([&#39;cart&#39; =&gt; $data]) $request-&gt;input(&#39;name&#39;), Request::get(&#39;name&#39;) $request-&gt;name, request(&#39;name&#39;) return Redirect::back() return back() is_null($object-&gt;relation) ? null : $object-&gt;relation-&gt;id optional($object-&gt;relation)-&gt;id return view(&#39;index&#39;)-&gt;with(&#39;title&#39;, $title)-&gt;with(&#39;client&#39;, $client) return view(&#39;index&#39;, compact(&#39;title&#39;, &#39;client&#39;)) $request-&gt;has(&#39;value&#39;) ? $request-&gt;value : &#39;default&#39;; $request-&gt;get(&#39;value&#39;, &#39;default&#39;) Carbon::now(), Carbon::today() now(), today() App::make(&#39;Class&#39;) app(&#39;Class&#39;) -&gt;where(&#39;column&#39;, &#39;=&#39;, 1) -&gt;where(&#39;column&#39;, 1) -&gt;orderBy(&#39;created_at&#39;, &#39;desc&#39;) -&gt;latest() -&gt;orderBy(&#39;age&#39;, &#39;desc&#39;) -&gt;latest(&#39;age&#39;) -&gt;orderBy(&#39;created_at&#39;, &#39;asc&#39;) -&gt;oldest() -&gt;select(&#39;id&#39;, &#39;name&#39;)-&gt;get() -&gt;get([&#39;id&#39;, &#39;name&#39;]) -&gt;first()-&gt;name -&gt;value(&#39;name&#39;) 🔝 回到顶部 Use IoC container or facades instead of new Class用控制反转容器或门面来取代new一个新的对象new一个新的对象的这种做法造成了类与复杂测试之间的强耦合，尽量使用控制反转或门面 不好的做法： 12$user = new User;$user-&gt;create($request-&gt;all()); 好的做法： 12345678public function __construct(User $user)&#123; $this-&gt;user = $user;&#125;....$this-&gt;user-&gt;create($request-&gt;all()); 🔝 回到顶部 Do not get data from the .env file directly不要直接从.env文件中读取数据把.env文件中的数据先传递到config文件中，再在应用中通过config()帮助方法使用 不好的做法： 1$apiKey = env('API_KEY'); 好的做法： 12345// config/api.php'key' =&gt; env('API_KEY'),// Use the data$apiKey = config('api.key'); 🔝 回到顶部 Store dates in the standard format. Use accessors and mutators to modify date format以标准格式存储数据，使用存取器和变异器来修改日期格式不好的做法： 12&#123;&#123; Carbon::createFromFormat('Y-d-m H-i', $object-&gt;ordered_at)-&gt;toDateString() &#125;&#125;&#123;&#123; Carbon::createFromFormat('Y-d-m H-i', $object-&gt;ordered_at)-&gt;format('m-d') &#125;&#125; 好的做法： 12345678910// Modelprotected $dates = ['ordered_at', 'created_at', 'updated_at']public function getSomeDateAttribute($date)&#123; return $date-&gt;format('m-d');&#125;// View&#123;&#123; $object-&gt;ordered_at-&gt;toDateString() &#125;&#125;&#123;&#123; $object-&gt;ordered_at-&gt;some_date &#125;&#125; 🔝 回到顶部 Other good practices其他好的实践不要在路径文件里写任何的逻辑 Blade模板中尽量不要使用原生的PHP语法 🔝 回到顶部","categories":[],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.guoguojia.net/tags/Laravel/"},{"name":"实践","slug":"实践","permalink":"http://blog.guoguojia.net/tags/实践/"}]},{"title":"这是第一篇测试文章","slug":"first-post","date":"2019-01-01T08:56:33.000Z","updated":"2019-01-01T08:56:33.989Z","comments":true,"path":"2019/01/01/first-post/","link":"","permalink":"http://blog.guoguojia.net/2019/01/01/first-post/","excerpt":"","text":"测试这里是第一篇文章","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.guoguojia.net/categories/Hexo/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://blog.guoguojia.net/tags/测试/"},{"name":"MD","slug":"MD","permalink":"http://blog.guoguojia.net/tags/MD/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-01T08:41:05.054Z","updated":"2019-01-01T08:41:05.054Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"http://blog.guoguojia.net/2019/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}